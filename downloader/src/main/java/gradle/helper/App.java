/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package gradle.helper;

import gradle.helper.model.DependenciesModel;
import gradle.helper.plugin.DependenciesModelPlugin;
import org.gradle.tooling.GradleConnector;
import org.gradle.tooling.ModelBuilder;
import org.gradle.tooling.ProjectConnection;
import picocli.CommandLine;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import static gradle.helper.plugin.DependenciesModelPlugin.DEPENDENCY_PREFIX;

@CommandLine.Command
public class App implements Runnable {
    private static final Pattern LINE_PATTERN = Pattern.compile(Pattern.quote(DEPENDENCY_PREFIX) + "(?:(.+?):(.+?):(.+))");
    private static final Pattern REPO_ARTIFACT = Pattern.compile("<a href=\"(.+?)\"");
    private static final List<String> REPOS = Arrays.asList(
            "https://repo.maven.apache.org/maven2/",
            "https://plugins.gradle.org/m2/",
            "https://repo.gradle.org/gradle/libs-releases/"
    );

    @CommandLine.Option(
            names = {"-b", "--build-directory"},
            description = "Path to the build directory to analyze",
            required = true
    )
    File buildDir;

    @CommandLine.Option(
            names = {"-o", "--output-file"},
            description = "Path to the output file",
            required = true
    )
    File outputFile;

    @CommandLine.Option(
            names = {"-w", "--write-repository"},
            description = "If set, dependencies will be downloaded in the target directory"
    )
    File repoDirectory;

    public static void main(String[] args) {
        int exitCode = new CommandLine(new App()).execute(args);
        System.exit(exitCode);
    }

    @Override
    public void run() {
        try {
            Path initGradle = Files.createTempFile("init", ".gradle");
            URL pluginLocation = DependenciesModelPlugin.class.getProtectionDomain().getCodeSource().getLocation();
            URL modelLocation = DependenciesModel.class.getProtectionDomain().getCodeSource().getLocation();
            Files.write(initGradle, Arrays.asList(
                    "initscript {",
                        "   dependencies {",
                        "      classpath files(\"" + new File(pluginLocation.toURI()).getCanonicalPath() + "\")",
                        "      classpath files(\"" + new File(modelLocation.toURI()).getCanonicalPath() + "\")",
                        "   }",
                    "}",
                    "rootProject {",
                    "   apply plugin: " + DependenciesModelPlugin.class.getName(),
                    "}"
            ), StandardCharsets.UTF_8);
            GradleConnector connector = GradleConnector.newConnector();
            connector.forProjectDirectory(buildDir);
            try (ProjectConnection connection = connector.connect()) {
                ModelBuilder<DependenciesModel> modelBuilder = connection.model(DependenciesModel.class);
                modelBuilder.withArguments("--init-script", initGradle.toString());
                modelBuilder.setStandardOutput(System.out);
                modelBuilder.setStandardError(System.err);
                DependenciesModel model = modelBuilder.get();
                writeDependenciesFile(model);
                if (repoDirectory != null) {
                    exportRepository();
                }
            }
        } catch (IOException | URISyntaxException e) {
            e.printStackTrace();
        }
    }

    private void exportRepository() throws IOException {
        mkdirs(repoDirectory);
        Files.readAllLines(outputFile.toPath()).stream()
                .map(LINE_PATTERN::matcher)
                .filter(Matcher::find)
                .forEach(m -> {
                    String group = m.group(1).replace('.', '/');
                    String artifact = m.group(2);
                    String version = m.group(3);
                    String path = group + "/" + artifact + "/" + version;
                    if (!version.endsWith("SNAPSHOT")) {
                        File f = new File(repoDirectory, path);
                        if (!f.isDirectory()) {
                            try {
                                List<String> tried = new ArrayList<>();
                                for (String repo : REPOS) {
                                    URL url = new URL(repo + path);
                                    try (InputStream in = url.openStream()) {
                                        BufferedReader reader = new BufferedReader(new InputStreamReader(in));
                                        String line;
                                        while ((line = reader.readLine()) != null) {
                                            Matcher artifactMatcher = REPO_ARTIFACT.matcher(line);
                                            if (artifactMatcher.find()) {
                                                mkdirs(f);
                                                String fileName = artifactMatcher.group(1);
                                                if (fileName.contains("..")) {
                                                    continue;
                                                }
                                                URL artifactURI = new URL(repo + path + "/" + fileName);
                                                System.out.println("Downloading = " + artifactURI);
                                                try (InputStream artifactIn = artifactURI.openStream()) {
                                                    Files.copy(artifactIn, new File(f, fileName).toPath());
                                                } catch (Exception ex) {
                                                    tried.add(artifactURI.toString());
                                                }
                                            }
                                        }
                                        tried.clear();
                                        break;
                                    } catch (FileNotFoundException fnfe) {
                                        tried.add(url.toString());
                                    }
                                }
                                if (!tried.isEmpty()) {
                                    for (String url : tried) {
                                        System.out.println(m.group(0) + " not found at " + url);
                                    }
                                }
                            } catch (IOException e) {
                                throw new RuntimeException(e);
                            }
                        }
                    }
                });
    }

    private void writeDependenciesFile(DependenciesModel model) throws IOException {
        try (PrintWriter writer = new PrintWriter(new FileWriter(outputFile))) {
            model.getDependencies().forEach((project, configurations) -> {
                writer.println("Project " + project);
                configurations.forEach((conf, dependencies) -> {
                    writer.println(conf);
                    writer.println(dependencies);
                });
            });
        }
    }

    private static void mkdirs(File path) {
        if (!path.isDirectory() && !path.mkdirs()) {
            throw new RuntimeException("Unable to create " + path);
        }
    }

}
